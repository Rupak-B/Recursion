// ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩  ⇩
// DO NOT ALTER THE TEXT BETWEEN THESE LINES =========={M{E{R{L{I{N{1}N}I}L}R}E}M}=====================================
let n = 7
// DO NOT ALTER THE TEXT BETWEEN THESE LINES =========={M{E{R{L{I{N{1}N}I}L}R}E}M}=====================================
// ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧  ⇧


// Add your code below:

//if the function is simple and has a answer of 1

func countDown(from target: Int) -> Int {
    if(target <= 1) {
        return 1
    } else {
      
        print("Calculating fibonacci(\(target))...")
        return countDown(from: target - 1)
    }
}



if (n>1) {
func fib(int: Int) -> Int {
 //solves the solved case of numbers less than 2 as well as 2 as an example for branching
    if(int <= 2){
        if(int  == 2 ) {
            print("Calculating fibonacci(\(2))...")
        }
        if (int == 1) {
    print("Calculating fibonacci(\(1))...")
        
        }
        print("Terminal case, returning 1.")
        return 1
    }
    else {
//branches down each path        
        print("Calculating fibonacci(\(int))...")
        let new = fib(int: int-1) + fib(int: int-2)
        print("Non-terminal case, returning \(new).")
        return new
    }
}
}
func call() {
    if(n<=1) {
print("Calculating fibonacci(\(n))...")        

print("Terminal case, returning \(countDown(from: n-1)).")
print("The final result is: \(1).")

}
print("The final result is: \(fib(int:n)).")

}
//the main function being called
call()
